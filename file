//File: blake2b.h
#pragma once
#ifndef __BLAKE2B_H__
#define __BLAKE2B_H__

#include <stddef.h>
#include <stdint.h>

#if defined(_MSC_VER) || defined(__x86_64__) || defined(__x86__)
#define NATIVE_LITTLE_ENDIAN
#endif

// state context
typedef struct {
    uint8_t b[128]; // input buffer
    uint64_t h[8];  // chained state
    uint64_t t[2];  // total number of bytes
    size_t c;       // pointer for b[]
    size_t outlen;  // digest size
} blake2b_ctx;

typedef struct {
    blake2b_ctx inner;
    blake2b_ctx outer;
} hmac_ctx;

#if defined(__cplusplus)
extern "C" {
#endif

int blake2b_init(blake2b_ctx *ctx, size_t outlen, const void *key, size_t keylen);
void blake2b_update(blake2b_ctx *ctx, const void *in, size_t inlen);
void blake2b_final(blake2b_ctx *ctx, void *out);
void blake2b_hash(void *out, const void *in, size_t inlen);
void hmac_blake2b_hash(void *out, const void *key, size_t keylen, const void *in, size_t inlen);
void pbkdf2_blake2b(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,
    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen);

#if defined(__cplusplus)
}
#endif

#endif





//File: blake2b.c
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "sph_types1.h"
#include "sysendian.h"
#include "blake2b.h"

// Cyclic right rotation.
#ifndef ROTR64
#define ROTR64(x, y)  (((x) >> (y)) ^ ((x) << (64 - (y))))
#endif

// Little-endian byte access.
#define B2B_GET64(p)                            \
    (((uint64_t) ((uint8_t *) (p))[0]) ^        \
    (((uint64_t) ((uint8_t *) (p))[1]) << 8) ^  \
    (((uint64_t) ((uint8_t *) (p))[2]) << 16) ^ \
    (((uint64_t) ((uint8_t *) (p))[3]) << 24) ^ \
    (((uint64_t) ((uint8_t *) (p))[4]) << 32) ^ \
    (((uint64_t) ((uint8_t *) (p))[5]) << 40) ^ \
    (((uint64_t) ((uint8_t *) (p))[6]) << 48) ^ \
    (((uint64_t) ((uint8_t *) (p))[7]) << 56))

// G Mixing function.
#define B2B_G(a, b, c, d, x, y) {   \
    v[a] = v[a] + v[b] + x;      \
    v[d] = ROTR64(v[d] ^ v[a], 32); \
    v[c] = v[c] + v[d];          \
    v[b] = ROTR64(v[b] ^ v[c], 24); \
    v[a] = v[a] + v[b] + y;      \
    v[d] = ROTR64(v[d] ^ v[a], 16); \
    v[c] = v[c] + v[d];          \
    v[b] = ROTR64(v[b] ^ v[c], 63); }

// Initialization Vector.
static const uint64_t blake2b_iv[8] = {
    0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,
    0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,
    0x510E527FADE682D1, 0x9B05688C2B3E6C1F,
    0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179
};

// Compression function. "last" flag indicates last block.
static void blake2b_compress(blake2b_ctx *ctx, int last)
{
    const uint8_t sigma[12][16] = {
        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
        { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
        { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
        { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
        { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
        { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
        { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
        { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
        { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
        { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
        { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 }
    };
    int i;
    uint64_t v[16], m[16];

    // init work variables
    for (i = 0; i < 8; i++) {
        v[i] = ctx->h[i];
        v[i + 8] = blake2b_iv[i];
    }

    v[12] ^= ctx->t[0]; // low 64 bits of offset
    v[13] ^= ctx->t[1]; // high 64 bits

    // last block flag set ?
    if (last) { 
        v[14] = ~v[14];
    }

    // get little-endian words
    for (i = 0; i < 16; i++) {
        m[i] = B2B_GET64(&ctx->b[8 * i]);
    }

    // twelve rounds
    for (i = 0; i < 12; i++) {
        B2B_G( 0, 4,  8, 12, m[sigma[i][ 0]], m[sigma[i][ 1]]);
        B2B_G( 1, 5,  9, 13, m[sigma[i][ 2]], m[sigma[i][ 3]]);
        B2B_G( 2, 6, 10, 14, m[sigma[i][ 4]], m[sigma[i][ 5]]);
        B2B_G( 3, 7, 11, 15, m[sigma[i][ 6]], m[sigma[i][ 7]]);
        B2B_G( 0, 5, 10, 15, m[sigma[i][ 8]], m[sigma[i][ 9]]);
        B2B_G( 1, 6, 11, 12, m[sigma[i][10]], m[sigma[i][11]]);
        B2B_G( 2, 7,  8, 13, m[sigma[i][12]], m[sigma[i][13]]);
        B2B_G( 3, 4,  9, 14, m[sigma[i][14]], m[sigma[i][15]]);
    }

    for(i = 0; i < 8; ++i) {
        ctx->h[i] ^= v[i] ^ v[i + 8];
    }
}

// Initialize the hashing context "ctx" with optional key "key".
// 1 <= outlen <= 64 gives the digest size in bytes.
// Secret key (also <= 64 bytes) is optional (keylen = 0).
int blake2b_init(blake2b_ctx *ctx, size_t outlen,
    const void *key, size_t keylen) // (keylen=0: no key)
{
    size_t i;

    // illegal parameters
    if (outlen == 0 || outlen > 64 || keylen > 64) {
        return -1;
    }

    // state, "param block"
    for (i = 0; i < 8; i++) {
        ctx->h[i] = blake2b_iv[i];
    }

    ctx->h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

    ctx->t[0] = 0; // input count low word
    ctx->t[1] = 0; // input count high word
    ctx->c = 0; // pointer within buffer
    ctx->outlen = outlen;

    // zero input block
    for (i = keylen; i < 128; i++) {
        ctx->b[i] = 0;
    }

    if (keylen > 0) {
        blake2b_update(ctx, key, keylen);
        ctx->c = 128; // at the end
    }

    return 0;
}

// Add "inlen" bytes from "in" into the hash.
void blake2b_update(blake2b_ctx *ctx,
    const void *in, size_t inlen) // data bytes
{
    size_t i;
    for (i = 0; i < inlen; i++) {
        if (ctx->c == 128) { // buffer full ?
            ctx->t[0] += ctx->c; // add counters
            if (ctx->t[0] < ctx->c) // carry overflow ?
                ctx->t[1]++; // high word
            blake2b_compress(ctx, 0); // compress (not last)
            ctx->c = 0; // counter to zero
        }
        ctx->b[ctx->c++] = ((const uint8_t *) in)[i];
    }
}

// Generate the message digest (size given in init).
// Result placed in "out".
void blake2b_final(blake2b_ctx *ctx, void *out)
{
    size_t i;

    ctx->t[0] += ctx->c; // mark last block offset
    // carry overflow
    if (ctx->t[0] < ctx->c) {
        ctx->t[1]++; // high word
    }

    // fill up with zeros
    while (ctx->c < 128) {
        ctx->b[ctx->c++] = 0;
    }

    blake2b_compress(ctx, 1); // final block flag = 1

    // little endian convert and store
    for (i = 0; i < ctx->outlen; i++) {
        ((uint8_t *) out)[i] =
            (ctx->h[i >> 3] >> (8 * (i & 7))) & 0xFF;
    }
}

// inlen = number of bytes
void blake2b_hash(void *out, const void *in, size_t inlen) {
    blake2b_ctx ctx;
    blake2b_init(&ctx, 32, NULL, 0);
    blake2b_update(&ctx, in, inlen);
    blake2b_final(&ctx, out);
}

// // keylen = number of bytes
void hmac_blake2b_init(hmac_ctx *hctx, const void *_key, size_t keylen) {
    const uint8_t *key = _key;
    uint8_t keyhash[32];
    uint8_t pad[64];
    uint64_t i;

    if (keylen > 64) {
        blake2b_hash(keyhash, key, keylen);
        key = keyhash;
        keylen = 32;
    }

    blake2b_init(&hctx->inner, 32, NULL, 0);
    memset(pad, 0x36, 64);
    for (i = 0; i < keylen; ++i) {
        pad[i] ^= key[i];
    }

    blake2b_update(&hctx->inner, pad, 64);
    blake2b_init(&hctx->outer, 32, NULL, 0);
    memset(pad, 0x5c, 64);
    for (i = 0; i < keylen; ++i) {
        pad[i] ^= key[i];
    }

    blake2b_update(&hctx->outer, pad, 64);
    memset(keyhash, 0, 32);
}

// datalen = number of bits
void hmac_blake2b_update(hmac_ctx *hctx, const void *data, size_t datalen) {
    // update the inner state
    blake2b_update(&hctx->inner, data, datalen);
}

void hmac_blake2b_final(hmac_ctx *hctx, uint8_t *digest) {
    uint8_t ihash[32];
    blake2b_final(&hctx->inner, ihash);
    blake2b_update(&hctx->outer, ihash, 32);
    blake2b_final(&hctx->outer, digest);
    memset(ihash, 0, 32);
}

// // keylen = number of bytes; inlen = number of bytes
void hmac_blake2b_hash(void *out, const void *key, size_t keylen, const void *in, size_t inlen) {
    hmac_ctx hctx;
    hmac_blake2b_init(&hctx, key, keylen);
    hmac_blake2b_update(&hctx, in, inlen);
    hmac_blake2b_final(&hctx, out);
}

void pbkdf2_blake2b(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,
    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)
{
    hmac_ctx PShctx, hctx;
    size_t i;
    uint8_t ivec[4];
    uint8_t U[32];
    uint8_t T[32];
    uint64_t j;
    int k;
    size_t clen;

    /* Compute HMAC state after processing P and S. */
    hmac_blake2b_init(&PShctx, passwd, passwdlen);
    hmac_blake2b_update(&PShctx, salt, saltlen);

    /* Iterate through the blocks. */
    for (i = 0; i * 32 < dkLen; i++) {
        /* Generate INT(i + 1). */
        be32enc(ivec, (uint32_t)(i + 1));

        /* Compute U_1 = PRF(P, S || INT(i)). */
        memcpy(&hctx, &PShctx, sizeof(hmac_ctx));
        hmac_blake2b_update(&hctx, ivec, 4);
        hmac_blake2b_final(&hctx, U);

        /* T_i = U_1 ... */
        memcpy(T, U, 32);

        for (j = 2; j <= c; j++) {
            /* Compute U_j. */
            hmac_blake2b_init(&hctx, passwd, passwdlen);
            hmac_blake2b_update(&hctx, U, 32);
            hmac_blake2b_final(&hctx, U);

            /* ... xor U_j ... */
            for (k = 0; k < 32; k++) {
                T[k] ^= U[k];
            }
        }

        /* Copy as many bytes as necessary into buf. */
        clen = dkLen - i * 32;
        if (clen > 32) {
            clen = 32;
        }

        memcpy(&buf[i * 32], T, clen);
    }

    /* Clean PShctx, since we never called _Final on it. */
    memset(&PShctx, 0, sizeof(hmac_ctx));
}





//File: sysendian.h
#ifndef _SYSENDIAN_H_
#define _SYSENDIAN_H_

#include <stdint.h>

#define be32dec libcperciva_be32dec
#define be32enc libcperciva_be32enc
#define be64enc libcperciva_be64enc
#define le32dec libcperciva_le32dec
#define le32enc libcperciva_le32enc

static inline uint32_t
be32dec(const void * pp)
{
    const uint8_t * p = (uint8_t const *)pp;

    return ((uint32_t)(p[3]) + ((uint32_t)(p[2]) << 8) +
        ((uint32_t)(p[1]) << 16) + ((uint32_t)(p[0]) << 24));
}

static inline void
be32enc(void * pp, uint32_t x)
{
    uint8_t * p = (uint8_t *)pp;

    p[3] = x & 0xff;
    p[2] = (x >> 8) & 0xff;
    p[1] = (x >> 16) & 0xff;
    p[0] = (x >> 24) & 0xff;
}

static inline void
be64enc(void * pp, uint64_t x)
{
    uint8_t * p = (uint8_t *)pp;

    p[7] = x & 0xff;
    p[6] = (x >> 8) & 0xff;
    p[5] = (x >> 16) & 0xff;
    p[4] = (x >> 24) & 0xff;
    p[3] = (x >> 32) & 0xff;
    p[2] = (x >> 40) & 0xff;
    p[1] = (x >> 48) & 0xff;
    p[0] = (x >> 56) & 0xff;
}

static inline uint32_t
le32dec(const void * pp)
{
    const uint8_t * p = (uint8_t const *)pp;

    return ((uint32_t)(p[0]) + ((uint32_t)(p[1]) << 8) +
        ((uint32_t)(p[2]) << 16) + ((uint32_t)(p[3]) << 24));
}

static inline void
le32enc(void * pp, uint32_t x)
{
    uint8_t * p = (uint8_t *)pp;

    p[0] = x & 0xff;
    p[1] = (x >> 8) & 0xff;
    p[2] = (x >> 16) & 0xff;
    p[3] = (x >> 24) & 0xff;
}

#endif




//File: sph_types1.h
#ifndef SPH_TYPES_H
#define SPH_TYPES_H

#include <stdint.h>
#include <stddef.h>
#include <string.h>

// Definisi tipe data dasar
typedef uint8_t byte;         // Byte 8-bit
typedef uint32_t u32;         // Integer unsigned 32-bit
typedef uint64_t u64;         // Integer unsigned 64-bit
typedef int32_t s32;          // Integer signed 32-bit
typedef int64_t s64;          // Integer signed 64-bit
typedef uint16_t u16;         // Integer unsigned 16-bit

// Definisi untuk ukuran hash
#define SPH_HASH_SIZE 64       // Misalnya hash panjang 64-byte
#define SPH_BLOCK_SIZE 128     // Ukuran blok untuk hash (contoh 128-byte)

typedef byte sph_hash[SPH_HASH_SIZE]; // Tipe untuk menyimpan hasil hash

// Struktur untuk menyimpan status hashing
typedef struct {
    u64 state[8];              // Status internal dari algoritma hashing
    u64 data[SPH_BLOCK_SIZE / sizeof(u64)];  // Blok data yang akan diproses
    size_t data_len;           // Panjang data yang sedang diproses dalam blok
    u64 length;                // Total panjang data yang telah diproses
} sph_ctx;

// Fungsi untuk menginisialisasi status hashing
static inline void sph_init(sph_ctx *ctx) {
    // Inisialisasi state dengan nilai default (contoh untuk algoritma hash internal)
    memset(ctx, 0, sizeof(sph_ctx));
    ctx->state[0] = 0x6a09e667f3bcc908; // Nilai standar untuk beberapa algoritma hash
    ctx->state[1] = 0xbb67ae8584caa73b;
    ctx->state[2] = 0x3c6ef372fe94f82b;
    ctx->state[3] = 0xa54ff53a5f1d36f1;
    ctx->state[4] = 0x510e527fade682d1;
    ctx->state[5] = 0x9b05688c2b3e6c1f;
    ctx->state[6] = 0x1f83d9abfb41bd6b;
    ctx->state[7] = 0x5be0cd19137e2179;
    ctx->length = 0;
    ctx->data_len = 0;
}

// Fungsi untuk memperbarui status hashing dengan data tambahan
static inline void sph_update(sph_ctx *ctx, const byte *data, size_t len) {
    size_t i;
    ctx->length += len * 8;  // Menambahkan panjang data dalam bit

    // Memproses data dalam blok
    while (len > 0) {
        size_t to_copy = (len < (SPH_BLOCK_SIZE - ctx->data_len)) ? len : (SPH_BLOCK_SIZE - ctx->data_len);
        memcpy((byte *)ctx->data + ctx->data_len, data, to_copy);
        ctx->data_len += to_copy;
        data += to_copy;
        len -= to_copy;

        // Jika blok penuh, lakukan perhitungan hash
        if (ctx->data_len == SPH_BLOCK_SIZE) {
            sph_process_block(ctx);
            ctx->data_len = 0;
        }
    }
}

// Fungsi untuk memproses satu blok data (hashing)
void sph_process_block(sph_ctx *ctx) {
    // Proses blok data di sini (misalnya dengan algoritma hashing berbasis VerusHash)
    // Dalam contoh ini, kita hanya melakukan operasi XOR sebagai placeholder
    for (int i = 0; i < SPH_BLOCK_SIZE / sizeof(u64); i++) {
        ctx->state[i % 8] ^= ctx->data[i]; // Operasi XOR sebagai contoh
    }
}

// Fungsi untuk menghasilkan hash akhir
static inline void sph_final(sph_ctx *ctx, sph_hash out) {
    size_t i;
    // Melakukan padding dan pengolahan akhir (contoh)
    ctx->data[ctx->data_len / sizeof(u64)] = ctx->length;
    sph_process_block(ctx);

    // Menyalin hasil hash ke output
    for (i = 0; i < SPH_HASH_SIZE / sizeof(u64); i++) {
        ((u64 *)out)[i] = ctx->state[i];
    }
}

// Fungsi untuk membalik urutan byte (endianness)
static inline u32 to_u32_le(const byte *p) {
    return ((u32)(p[0])) | ((u32)(p[1]) << 8) | ((u32)(p[2]) << 16) | ((u32)(p[3]) << 24);
}

static inline void from_u32_le(byte *p, u32 x) {
    p[0] = (byte)(x & 0xff);
    p[1] = (byte)((x >> 8) & 0xff);
    p[2] = (byte)((x >> 16) & 0xff);
    p[3] = (byte)((x >> 24) & 0xff);
}

#endif // SPH_TYPES_H
